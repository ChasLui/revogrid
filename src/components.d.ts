/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { ApplyFocusEvent, BeforeCellRenderEvent, BeforeRowRenderEvent, ColumnGrouping, ColumnProp, ColumnRegular, ColumnType, DataFormat, DataType, DimensionSettingsState, DragStartEvent, FocusRenderEvent, FocusTemplateFunc, InitialHeaderClick, Observable, PositionItem, Providers, RowDefinition, RowHeaders, ViewPortResizeEvent, ViewPortScrollEvent, ViewportState, ViewSettingSizeProp } from "./types/interfaces";
import { BeforeEdit, BeforeRangeSaveDataDetails, BeforeSaveDataDetails, Cell, ChangedRange, EditCell, EditorCtr, Editors, RangeArea, SaveDataDetails, SelectionStoreState, TempRange } from "./types/selection";
import { PluginBaseComponent, PluginExternalConstructor } from "./types/plugin";
import { Theme } from "./types/theme";
import { AutoSizeColumnConfig } from "./plugins/column.auto-size.plugin";
import { ColumnFilterConfig, FilterCaptions, FilterCollection } from "./plugins/filter/filter.plugin";
import { GroupingOptions } from "./plugins/groupingRow/grouping.row.types";
import { DimensionCols, DimensionRows, DimensionType, MultiDimensionType } from "./types/dimension";
import { FocusedData } from "./components/revoGrid/viewport.service";
import { ColumnCollection } from "./services/column.data.provider";
import { DataInput } from "./plugins/export/types";
import { VNode } from "@stencil/core";
import { ColumnSource, RowSource } from "./components/data/column.service";
import { MultiFilterItem, ShowData } from "./plugins/filter/filter.pop";
import { LogicFunction } from "./plugins/filter/filter.types";
import { DSourceState, Groups } from "./store/dataSource/data.store";
import { ResizeProps } from "./services/resizable.directive";
import { Cell as Cell1, ColumnRegular as ColumnRegular1, DataType as DataType1, DimensionCols as DimensionCols1, DimensionRows as DimensionRows1, DimensionSettingsState as DimensionSettingsState1, Observable as Observable1, SelectionStoreState as SelectionStoreState1 } from "./components";
import { ViewportData } from "./types/viewport.interfaces";
import { ElementScroll } from "./components/revoGrid/viewport.scrolling.service";
export { ApplyFocusEvent, BeforeCellRenderEvent, BeforeRowRenderEvent, ColumnGrouping, ColumnProp, ColumnRegular, ColumnType, DataFormat, DataType, DimensionSettingsState, DragStartEvent, FocusRenderEvent, FocusTemplateFunc, InitialHeaderClick, Observable, PositionItem, Providers, RowDefinition, RowHeaders, ViewPortResizeEvent, ViewPortScrollEvent, ViewportState, ViewSettingSizeProp } from "./types/interfaces";
export { BeforeEdit, BeforeRangeSaveDataDetails, BeforeSaveDataDetails, Cell, ChangedRange, EditCell, EditorCtr, Editors, RangeArea, SaveDataDetails, SelectionStoreState, TempRange } from "./types/selection";
export { PluginBaseComponent, PluginExternalConstructor } from "./types/plugin";
export { Theme } from "./types/theme";
export { AutoSizeColumnConfig } from "./plugins/column.auto-size.plugin";
export { ColumnFilterConfig, FilterCaptions, FilterCollection } from "./plugins/filter/filter.plugin";
export { GroupingOptions } from "./plugins/groupingRow/grouping.row.types";
export { DimensionCols, DimensionRows, DimensionType, MultiDimensionType } from "./types/dimension";
export { FocusedData } from "./components/revoGrid/viewport.service";
export { ColumnCollection } from "./services/column.data.provider";
export { DataInput } from "./plugins/export/types";
export { VNode } from "@stencil/core";
export { ColumnSource, RowSource } from "./components/data/column.service";
export { MultiFilterItem, ShowData } from "./plugins/filter/filter.pop";
export { LogicFunction } from "./plugins/filter/filter.types";
export { DSourceState, Groups } from "./store/dataSource/data.store";
export { ResizeProps } from "./services/resizable.directive";
export { Cell as Cell1, ColumnRegular as ColumnRegular1, DataType as DataType1, DimensionCols as DimensionCols1, DimensionRows as DimensionRows1, DimensionSettingsState as DimensionSettingsState1, Observable as Observable1, SelectionStoreState as SelectionStoreState1 } from "./components";
export { ViewportData } from "./types/viewport.interfaces";
export { ElementScroll } from "./components/revoGrid/viewport.scrolling.service";
export namespace Components {
    /**
     * Slots
     * @example data-rgCol-rgRow - main data slot
     * @example focus-rgCol-rgRow - focus layer for main data
     */
    interface RevoGrid {
        /**
          * Add trimmed by type
         */
        "addTrimmed": (trimmed: Record<number, boolean>, trimmedType?: string, type?: DimensionRows) => Promise<CustomEvent<{ trimmed: Record<number, boolean>; trimmedType: string; type: string; }>>;
        /**
          * Additional data to be passed to plugins, renders, editors
         */
        "additionalData": any;
        /**
          * Apply changes typed in editor on editor close except Escape cases If custom editor in use
          * @method getValue required Check interfaces.d.ts
          * @EditorBase for more info
         */
        "applyOnClose": boolean;
        /**
          * Autosize config Enable columns autoSize, for more details check
          * @autoSizeColumn plugin By default disabled, hence operation is not resource efficient true to enable with default params (double header separator click for autosize) or provide config
         */
        "autoSizeColumn": boolean | AutoSizeColumnConfig;
        /**
          * When true cell focus appear.
         */
        "canFocus": boolean;
        /**
          * Enables column move plugin Can be boolean
         */
        "canMoveColumns": boolean;
        /**
          * Clear current grid focus
         */
        "clearFocus": () => Promise<void>;
        /**
          * Clears column sorting
         */
        "clearSorting": () => Promise<void>;
        /**
          * Indicates default column size.
         */
        "colSize": number;
        /**
          * Column Types Format Every type represent multiple column properties Types will be merged but can be replaced with column properties Types were made as separate objects to be reusable per multiple columns
         */
        "columnTypes": { [name: string]: ColumnType };
        /**
          * Columns - defines an array of grid columns. Can be column or grouped column.
         */
        "columns": (ColumnRegular | ColumnGrouping)[];
        /**
          * Disable lazy rendering mode for the X axis Use when not many columns present and you don't need rerenader cells during scroll
         */
        "disableVirtualX": boolean;
        /**
          * Disable lazy rendering mode for the Y axis Use when not many rows present and you don't need rerenader cells during scroll
         */
        "disableVirtualY": boolean;
        /**
          * Custom editors register
         */
        "editors": Editors;
        /**
          * Enables export plugin Can be boolean Can be export options
         */
        "exporting": boolean;
        /**
          * Enables filter plugin Can be boolean Can be filter collection
         */
        "filter": boolean | ColumnFilterConfig;
        /**
          * Apply changes typed in editor on editor close except Escape cases If custom editor in use
          * @method getValue required Check interfaces.d.ts
          * @EditorBase for more info
         */
        "focusTemplate": FocusTemplateFunc;
        /**
          * Defines how many rows/columns should be rendered outside visible area.
         */
        "frameSize": number;
        /**
          * Provides access to column internal store observer Can be used for plugin support
          * @param type - type of column
         */
        "getColumnStore": (type?: DimensionCols) => Promise<ColumnSource>;
        /**
          * Receive all columns in data source
         */
        "getColumns": () => Promise<ColumnRegular[]>;
        /**
          * Get size of content Including all pinned data
         */
        "getContentSize": () => Promise<Cell>;
        /**
          * Get the currently focused cell.
         */
        "getFocused": () => Promise<FocusedData | null>;
        /**
          * Get all active plugins instances
         */
        "getPlugins": () => Promise<PluginBaseComponent[]>;
        /**
          * Get the currently selected Range.
         */
        "getSelectedRange": () => Promise<RangeArea | null>;
        /**
          * Get data from source
         */
        "getSource": (type?: DimensionRows) => Promise<DataType[]>;
        /**
          * Provides access to rows internal store observer Can be used for plugin support
          * @param type - type of source
         */
        "getSourceStore": (type?: DimensionRows) => Promise<RowSource>;
        /**
          * Get data from visible part of source Trimmed/filtered rows will be excluded
          * @param type - type of source
         */
        "getVisibleSource": (type?: DimensionRows) => Promise<any[]>;
        /**
          * Group models by provided properties Define properties to be groped by
         */
        "grouping": GroupingOptions;
        /**
          * Prevents rendering until job is done. Can be used for initial rendering performance improvement. When several plugins require initial rendering this will prevent double initial rendering.
         */
        "jobsBeforeRender": Promise<any>[];
        /**
          * Pinned bottom Source: {[T in ColumnProp]: any} - defines pinned bottom rows data source.
         */
        "pinnedBottomSource": DataType[];
        /**
          * Pinned top Source: {[T in ColumnProp]: any} - defines pinned top rows data source.
         */
        "pinnedTopSource": DataType[];
        /**
          * Custom grid plugins Has to be predefined during first grid init Every plugin should be inherited from BasePlugin
         */
        "plugins": PluginExternalConstructor[];
        /**
          * When true, user can range selection.
         */
        "range": boolean;
        /**
          * When true, grid in read only mode.
         */
        "readonly": boolean;
        /**
          * Refreshes data viewport. Can be specific part as rgRow or pinned rgRow or 'all' by default.
         */
        "refresh": (type?: DimensionRows | 'all') => Promise<void>;
        /**
          * Register new virtual node inside of grid Used for additional items creation such as plugin elements
         */
        "registerVNode": (elements: VNode[]) => Promise<void>;
        /**
          * When true, columns are resizable.
         */
        "resize": boolean;
        /**
          * Row class property Define this property in rgRow object and this will be mapped as rgRow class
         */
        "rowClass": string;
        /**
          * Row properies applied
         */
        "rowDefinitions": RowDefinition[];
        /**
          * Excel like show rgRow indexe per rgRow
         */
        "rowHeaders": RowHeaders | boolean;
        /**
          * Indicates default rgRow size. By default 0, means theme package size will be applied
         */
        "rowSize": number;
        /**
          * Scrolls view port to specified column index
         */
        "scrollToColumnIndex": (coordinate?: number) => Promise<void>;
        /**
          * Scrolls view port to specified column prop
         */
        "scrollToColumnProp": (prop: ColumnProp) => Promise<void>;
        /**
          * Scrolls view port to coordinate
         */
        "scrollToCoordinate": (cell: Partial<Cell>) => Promise<void>;
        /**
          * Scrolls view port to specified rgRow index
         */
        "scrollToRow": (coordinate?: number) => Promise<void>;
        /**
          * Bring cell to edit mode
         */
        "setCellEdit": (rgRow: number, prop: ColumnProp, rowSource?: DimensionRows) => Promise<void>;
        /**
          * Set focus range
         */
        "setCellsFocus": (cellStart?: Cell, cellEnd?: Cell, colType?: string, rowType?: string) => Promise<void>;
        /**
          * Source - defines main data source. Can be an Object or 2 dimensional array([][]); Keys/indexes referenced from columns Prop
         */
        "source": DataType[];
        /**
          * Defines stretch strategy for columns with
          * @StretchColumn plugin if there are more space on the right last column size would be increased
         */
        "stretch": boolean | string;
        /**
          * Theme name
         */
        "theme": Theme;
        /**
          * Trimmed rows Functionality which allows to hide rows from main data set
          * @trimmedRows are physical rgRow indexes to hide
         */
        "trimmedRows": Record<number, boolean>;
        /**
          * Update column sorting
          * @param column - full column details to update
          * @param index - virtual column index
          * @param order - order to apply
         */
        "updateColumnSorting": (column: ColumnRegular, index: number, order: 'asc' | 'desc', additive: boolean) => Promise<ColumnRegular>;
        /**
          * Update columns
         */
        "updateColumns": (cols: ColumnRegular[]) => Promise<void>;
        /**
          * When true enable clipboard.
         */
        "useClipboard": boolean;
    }
    /**
     * Component is responsible for rendering cell
     * Main purpose is to track changes and understand what exactly need to be rerendered instead of full grid render
     */
    interface RevogrCell {
        /**
          * Additional data to pass to renderer Used in plugins such as vue or react to pass root app entity to cells
         */
        "additionalData": any;
        "colEnd": number;
        /**
          * Column props passed via property
         */
        "colIndex": number;
        "colSize": number;
        "colStart": number;
        /**
          * Column service
         */
        "columnService": ColumnService;
        /**
          * Grouping
         */
        "depth": number;
        /**
          * Cached providers
         */
        "providers": Providers;
        "rowEnd": number;
        /**
          * Row props passed via property
         */
        "rowIndex": number;
        "rowSize": number;
        "rowStart": number;
    }
    interface RevogrClipboard {
        "doCopy": (e: DataTransfer, data?: DataFormat[][]) => Promise<void>;
        /**
          * If readonly mode enables no need for Paste event
         */
        "readonly": boolean;
    }
    /**
     * This component is responsible for rendering data
     * Rows, columns, groups and cells
     */
    interface RevogrData {
        /**
          * Additional data to pass to renderer Used in plugins such as vue or react to pass root app entity to cells
         */
        "additionalData": any;
        /**
          * Static stores, not expected to change during component lifetime
         */
        "colData": ColumnSource;
        "dataStore": RowSource;
        "dimensionRow": Observable<DimensionSettingsState>;
        /**
          * Range allowed
         */
        "range": boolean;
        /**
          * Readonly mode
         */
        "readonly": boolean;
        /**
          * Defines property from which to read row class
         */
        "rowClass": string;
        /**
          * Stores
         */
        "rowSelectionStore": Observable<SelectionStoreState>;
        "type": DimensionRows;
        "viewportCol": Observable<ViewportState>;
        "viewportRow": Observable<ViewportState>;
    }
    /**
     * Cell editor component
     */
    interface RevogrEdit {
        /**
          * Additional data to pass to renderer
         */
        "additionalData": any;
        "cancel": () => Promise<void>;
        "column": ColumnRegular | null;
        "editCell": EditCell;
        /**
          * Custom editors register
         */
        "editor": EditorCtr | null;
        /**
          * Save on editor close
         */
        "saveOnClose": boolean;
    }
    interface RevogrFilterPanel {
        "disableDynamicFiltering": boolean;
        "filterCaptions": FilterCaptions | undefined;
        "filterEntities": Record<string, LogicFunction>;
        "filterItems": MultiFilterItem;
        "filterNames": Record<string, string>;
        "filterTypes": Record<string, string[]>;
        "getChanges": () => Promise<ShowData>;
        "show": (newEntity?: ShowData) => Promise<void>;
        "uuid": string;
    }
    interface RevogrFocus {
        "colData": ColumnSource;
        "colType": DimensionCols;
        "dataStore": RowSource;
        "dimensionCol": Observable<DimensionSettingsState>;
        "dimensionRow": Observable<DimensionSettingsState>;
        "focusTemplate": FocusTemplateFunc | null;
        "rowType": DimensionRows;
        /**
          * Dynamic stores
         */
        "selectionStore": Observable<SelectionStoreState>;
    }
    interface RevogrHeader {
        /**
          * Extra properties to pass into header renderer, such as vue or react components to handle parent
         */
        "additionalData": any;
        /**
          * If columns can be resized
         */
        "canResize": boolean;
        /**
          * Columns - defines an array of grid columns.
         */
        "colData": ColumnRegular[];
        /**
          * Column filter
         */
        "columnFilter": boolean;
        "dimensionCol": Observable<DimensionSettingsState>;
        "groupingDepth": number;
        "groups": Groups;
        "parent": string;
        /**
          * Readonly mode
         */
        "readonly": boolean;
        /**
          * Defines resize position
         */
        "resizeHandler": ResizeProps['active'];
        "selectionStore": Observable<SelectionStoreState>;
        /**
          * Column type
         */
        "type": DimensionCols | 'rowHeaders';
        /**
          * Stores
         */
        "viewportCol": Observable<ViewportState>;
    }
    interface RevogrOrderEditor {
        "clearOrder": () => Promise<void>;
        /**
          * Static stores, not expected to change during component lifetime
         */
        "dataStore": Observable<DSourceState<DataType, DimensionRows>>;
        "dimensionCol": Observable<DimensionSettingsState>;
        "dimensionRow": Observable<DimensionSettingsState>;
        "dragStart": (e: DragStartEvent) => Promise<void>;
        "endOrder": (e: MouseEvent) => Promise<void>;
        "parent": HTMLElement;
    }
    interface RevogrOverlaySelection {
        /**
          * Additional data to pass to renderer
         */
        "additionalData": any;
        /**
          * If true applys changes when cell closes if not Escape
         */
        "applyChangesOnClose": boolean;
        /**
          * Enable revogr-order-editor component (read more in revogr-order-editor component) Allows D&D
         */
        "canDrag": boolean;
        /**
          * Column data store
         */
        "colData": Observable1<DSourceState<ColumnRegular1, DimensionCols1>>;
        /**
          * Row data store
         */
        "dataStore": Observable1<DSourceState<DataType1, DimensionRows1>>;
        "dimensionCol": Observable1<DimensionSettingsState1>;
        "dimensionRow": Observable1<DimensionSettingsState1>;
        /**
          * Custom editors register
         */
        "editors": Editors;
        /**
          * Is mobile view mode
         */
        "isMobileDevice": boolean;
        /**
          * Last cell position
         */
        "lastCell": Cell1;
        /**
          * Range selection mode
         */
        "range": boolean;
        /**
          * If readonly mode enables
         */
        "readonly": boolean;
        "selectionStore": Observable1<SelectionStoreState1>;
        /**
          * Enable revogr-clipboard component (read more in revogr-clipboard component) Allows copy/paste
         */
        "useClipboard": boolean;
    }
    /**
     * Row headers component
     * Visible on the left side of the table
     */
    interface RevogrRowHeaders {
        /**
          * Additional data to pass to renderer
         */
        "additionalData": any;
        "dataPorts": ViewportData[];
        "headerProp": Record<string, any>;
        "height": number;
        "resize": boolean;
        "rowClass": string;
        "rowHeaderColumn": RowHeaders;
        "uiid": string;
    }
    interface RevogrScrollVirtual {
        "changeScroll": (e: ViewPortScrollEvent) => Promise<ViewPortScrollEvent>;
        "dimension": DimensionType;
        "dimensionStore": Observable<DimensionSettingsState>;
        "setScroll": (e: ViewPortScrollEvent) => Promise<void>;
        "viewportStore": Observable<ViewportState>;
    }
    /**
     * Temporary range selection
     */
    interface RevogrTempRange {
        /**
          * Dimension column store
         */
        "dimensionCol": Observable<DimensionSettingsState>;
        /**
          * Dimension row store
         */
        "dimensionRow": Observable<DimensionSettingsState>;
        /**
          * Selection store, shows current selection and focus
         */
        "selectionStore": Observable<SelectionStoreState>;
    }
    interface RevogrViewportScroll {
        /**
          * Extra layer for scroll event monitoring, where MouseWheel event is not passing We need to trigger scroll event in case there is no mousewheel event
         */
        "applyScroll": (type: DimensionType, e: UIEvent) => Promise<void>;
        /**
          * update on delta in case we don't know existing position or external change
          * @param e
         */
        "changeScroll": (e: ViewPortScrollEvent, silent?: boolean) => Promise<ViewPortScrollEvent>;
        /**
          * Height of inner content
         */
        "contentHeight": number;
        /**
          * Width of inner content
         */
        "contentWidth": number;
        "rowHeader": boolean;
        "setScroll": (e: ViewPortScrollEvent) => Promise<void>;
    }
}
export interface RevoGridCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevoGridElement;
}
export interface RevogrCellCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrCellElement;
}
export interface RevogrClipboardCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrClipboardElement;
}
export interface RevogrDataCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrDataElement;
}
export interface RevogrEditCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrEditElement;
}
export interface RevogrFilterPanelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrFilterPanelElement;
}
export interface RevogrFocusCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrFocusElement;
}
export interface RevogrHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrHeaderElement;
}
export interface RevogrOrderEditorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrOrderEditorElement;
}
export interface RevogrOverlaySelectionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrOverlaySelectionElement;
}
export interface RevogrRowHeadersCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrRowHeadersElement;
}
export interface RevogrScrollVirtualCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrScrollVirtualElement;
}
export interface RevogrViewportScrollCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrViewportScrollElement;
}
declare global {
    /**
     * Slots
     * @example data-rgCol-rgRow - main data slot
     * @example focus-rgCol-rgRow - focus layer for main data
     */
    interface HTMLRevoGridElement extends Components.RevoGrid, HTMLStencilElement {
    }
    var HTMLRevoGridElement: {
        prototype: HTMLRevoGridElement;
        new (): HTMLRevoGridElement;
    };
    /**
     * Component is responsible for rendering cell
     * Main purpose is to track changes and understand what exactly need to be rerendered instead of full grid render
     */
    interface HTMLRevogrCellElement extends Components.RevogrCell, HTMLStencilElement {
    }
    var HTMLRevogrCellElement: {
        prototype: HTMLRevogrCellElement;
        new (): HTMLRevogrCellElement;
    };
    interface HTMLRevogrClipboardElement extends Components.RevogrClipboard, HTMLStencilElement {
    }
    var HTMLRevogrClipboardElement: {
        prototype: HTMLRevogrClipboardElement;
        new (): HTMLRevogrClipboardElement;
    };
    /**
     * This component is responsible for rendering data
     * Rows, columns, groups and cells
     */
    interface HTMLRevogrDataElement extends Components.RevogrData, HTMLStencilElement {
    }
    var HTMLRevogrDataElement: {
        prototype: HTMLRevogrDataElement;
        new (): HTMLRevogrDataElement;
    };
    /**
     * Cell editor component
     */
    interface HTMLRevogrEditElement extends Components.RevogrEdit, HTMLStencilElement {
    }
    var HTMLRevogrEditElement: {
        prototype: HTMLRevogrEditElement;
        new (): HTMLRevogrEditElement;
    };
    interface HTMLRevogrFilterPanelElement extends Components.RevogrFilterPanel, HTMLStencilElement {
    }
    var HTMLRevogrFilterPanelElement: {
        prototype: HTMLRevogrFilterPanelElement;
        new (): HTMLRevogrFilterPanelElement;
    };
    interface HTMLRevogrFocusElement extends Components.RevogrFocus, HTMLStencilElement {
    }
    var HTMLRevogrFocusElement: {
        prototype: HTMLRevogrFocusElement;
        new (): HTMLRevogrFocusElement;
    };
    interface HTMLRevogrHeaderElement extends Components.RevogrHeader, HTMLStencilElement {
    }
    var HTMLRevogrHeaderElement: {
        prototype: HTMLRevogrHeaderElement;
        new (): HTMLRevogrHeaderElement;
    };
    interface HTMLRevogrOrderEditorElement extends Components.RevogrOrderEditor, HTMLStencilElement {
    }
    var HTMLRevogrOrderEditorElement: {
        prototype: HTMLRevogrOrderEditorElement;
        new (): HTMLRevogrOrderEditorElement;
    };
    interface HTMLRevogrOverlaySelectionElement extends Components.RevogrOverlaySelection, HTMLStencilElement {
    }
    var HTMLRevogrOverlaySelectionElement: {
        prototype: HTMLRevogrOverlaySelectionElement;
        new (): HTMLRevogrOverlaySelectionElement;
    };
    /**
     * Row headers component
     * Visible on the left side of the table
     */
    interface HTMLRevogrRowHeadersElement extends Components.RevogrRowHeaders, HTMLStencilElement {
    }
    var HTMLRevogrRowHeadersElement: {
        prototype: HTMLRevogrRowHeadersElement;
        new (): HTMLRevogrRowHeadersElement;
    };
    interface HTMLRevogrScrollVirtualElement extends Components.RevogrScrollVirtual, HTMLStencilElement {
    }
    var HTMLRevogrScrollVirtualElement: {
        prototype: HTMLRevogrScrollVirtualElement;
        new (): HTMLRevogrScrollVirtualElement;
    };
    /**
     * Temporary range selection
     */
    interface HTMLRevogrTempRangeElement extends Components.RevogrTempRange, HTMLStencilElement {
    }
    var HTMLRevogrTempRangeElement: {
        prototype: HTMLRevogrTempRangeElement;
        new (): HTMLRevogrTempRangeElement;
    };
    interface HTMLRevogrViewportScrollElement extends Components.RevogrViewportScroll, HTMLStencilElement {
    }
    var HTMLRevogrViewportScrollElement: {
        prototype: HTMLRevogrViewportScrollElement;
        new (): HTMLRevogrViewportScrollElement;
    };
    interface HTMLElementTagNameMap {
        "revo-grid": HTMLRevoGridElement;
        "revogr-cell": HTMLRevogrCellElement;
        "revogr-clipboard": HTMLRevogrClipboardElement;
        "revogr-data": HTMLRevogrDataElement;
        "revogr-edit": HTMLRevogrEditElement;
        "revogr-filter-panel": HTMLRevogrFilterPanelElement;
        "revogr-focus": HTMLRevogrFocusElement;
        "revogr-header": HTMLRevogrHeaderElement;
        "revogr-order-editor": HTMLRevogrOrderEditorElement;
        "revogr-overlay-selection": HTMLRevogrOverlaySelectionElement;
        "revogr-row-headers": HTMLRevogrRowHeadersElement;
        "revogr-scroll-virtual": HTMLRevogrScrollVirtualElement;
        "revogr-temp-range": HTMLRevogrTempRangeElement;
        "revogr-viewport-scroll": HTMLRevogrViewportScrollElement;
    }
}
declare namespace LocalJSX {
    /**
     * Slots
     * @example data-rgCol-rgRow - main data slot
     * @example focus-rgCol-rgRow - focus layer for main data
     */
    interface RevoGrid {
        /**
          * Additional data to be passed to plugins, renders, editors
         */
        "additionalData"?: any;
        /**
          * Apply changes typed in editor on editor close except Escape cases If custom editor in use
          * @method getValue required Check interfaces.d.ts
          * @EditorBase for more info
         */
        "applyOnClose"?: boolean;
        /**
          * Autosize config Enable columns autoSize, for more details check
          * @autoSizeColumn plugin By default disabled, hence operation is not resource efficient true to enable with default params (double header separator click for autosize) or provide config
         */
        "autoSizeColumn"?: boolean | AutoSizeColumnConfig;
        /**
          * When true cell focus appear.
         */
        "canFocus"?: boolean;
        /**
          * Enables column move plugin Can be boolean
         */
        "canMoveColumns"?: boolean;
        /**
          * Indicates default column size.
         */
        "colSize"?: number;
        /**
          * Column Types Format Every type represent multiple column properties Types will be merged but can be replaced with column properties Types were made as separate objects to be reusable per multiple columns
         */
        "columnTypes"?: { [name: string]: ColumnType };
        /**
          * Columns - defines an array of grid columns. Can be column or grouped column.
         */
        "columns"?: (ColumnRegular | ColumnGrouping)[];
        /**
          * Disable lazy rendering mode for the X axis Use when not many columns present and you don't need rerenader cells during scroll
         */
        "disableVirtualX"?: boolean;
        /**
          * Disable lazy rendering mode for the Y axis Use when not many rows present and you don't need rerenader cells during scroll
         */
        "disableVirtualY"?: boolean;
        /**
          * Custom editors register
         */
        "editors"?: Editors;
        /**
          * Enables export plugin Can be boolean Can be export options
         */
        "exporting"?: boolean;
        /**
          * Enables filter plugin Can be boolean Can be filter collection
         */
        "filter"?: boolean | ColumnFilterConfig;
        /**
          * Apply changes typed in editor on editor close except Escape cases If custom editor in use
          * @method getValue required Check interfaces.d.ts
          * @EditorBase for more info
         */
        "focusTemplate"?: FocusTemplateFunc;
        /**
          * Defines how many rows/columns should be rendered outside visible area.
         */
        "frameSize"?: number;
        /**
          * Group models by provided properties Define properties to be groped by
         */
        "grouping"?: GroupingOptions;
        /**
          * Prevents rendering until job is done. Can be used for initial rendering performance improvement. When several plugins require initial rendering this will prevent double initial rendering.
         */
        "jobsBeforeRender"?: Promise<any>[];
        /**
          * After all rows updated. Use it if you want to track all changes from sources pinned and main
         */
        "onAfter-any-source"?: (event: RevoGridCustomEvent<{
    type: DimensionRows;
    source: DataType[];
  }>) => void;
        /**
          * After column resize Get resized columns
         */
        "onAftercolumnresize"?: (event: RevoGridCustomEvent<{
    [index: number]: ColumnRegular;
  }>) => void;
        /**
          * Column updated
         */
        "onAftercolumnsset"?: (event: RevoGridCustomEvent<{
    columns: ColumnCollection;
    order: Record<ColumnProp, 'asc' | 'desc'>;
  }>) => void;
        /**
          * After edit. Triggered after data applied or range changed.
         */
        "onAfteredit"?: (event: RevoGridCustomEvent<BeforeSaveDataDetails | BeforeRangeSaveDataDetails>) => void;
        /**
          * Triggered after focus render finished. Can be used to access a focus element through
          * @event .target
         */
        "onAfterfocus"?: (event: RevoGridCustomEvent<{
    model: any;
    column: ColumnRegular;
  }>) => void;
        /**
          * After rows updated
         */
        "onAftersourceset"?: (event: RevoGridCustomEvent<{
    type: DimensionRows;
    source: DataType[];
  }>) => void;
        /**
          * Notify trimmed applied
         */
        "onAftertrimmed"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * Before data apply. You can override data source here
         */
        "onBefore-any-source"?: (event: RevoGridCustomEvent<{
    type: DimensionRows;
    source: DataType[];
  }>) => void;
        /**
          * Before range apply. Triggered before range applied. Use e.preventDefault() to prevent range.
         */
        "onBeforeange"?: (event: RevoGridCustomEvent<ChangedRange>) => void;
        /**
          * Before autofill. Triggered before autofill applied. Use e.preventDefault() to prevent edit data apply.
         */
        "onBeforeautofill"?: (event: RevoGridCustomEvent<ChangedRange>) => void;
        /**
          * Before cell focus changed. Use e.preventDefault() to prevent cell focus change.
         */
        "onBeforecellfocus"?: (event: RevoGridCustomEvent<BeforeSaveDataDetails>) => void;
        /**
          * Before column applied but after column set gathered and viewport updated
         */
        "onBeforecolumnapplied"?: (event: RevoGridCustomEvent<ColumnCollection>) => void;
        /**
          * Before column update
         */
        "onBeforecolumnsset"?: (event: RevoGridCustomEvent<ColumnCollection>) => void;
        /**
          * Before edit event. Triggered before edit data applied. Use e.preventDefault() to prevent edit data set and use you own. Use e.val = {your value} to replace edit result with your own.
         */
        "onBeforeedit"?: (event: RevoGridCustomEvent<BeforeSaveDataDetails>) => void;
        /**
          * Before edit started Use e.preventDefault() to prevent edit
         */
        "onBeforeeditstart"?: (event: RevoGridCustomEvent<BeforeSaveDataDetails>) => void;
        /**
          * Before export Use e.preventDefault() to prevent export Replace data in Event in case you want to modify it in export
         */
        "onBeforeexport"?: (event: RevoGridCustomEvent<DataInput>) => void;
        /**
          * Before filter applied to data source Use e.preventDefault() to prevent cell focus change Update
          * @collection if you wish to change filters
         */
        "onBeforefilterapply"?: (event: RevoGridCustomEvent<{ collection: FilterCollection }>) => void;
        /**
          * Before filter trimmed values Use e.preventDefault() to prevent value trimming and filter apply Update
          * @collection if you wish to change filters Update
          * @itemsToFilter if you wish to filter indexes of trimming
         */
        "onBeforefiltertrimmed"?: (event: RevoGridCustomEvent<{
    collection: FilterCollection;
    itemsToFilter: Record<number, boolean>;
  }>) => void;
        /**
          * Before grid focus lost happened. Use e.preventDefault() to prevent cell focus change.
         */
        "onBeforefocuslost"?: (event: RevoGridCustomEvent<FocusedData | null>) => void;
        /**
          * Before range edit event. Triggered before range data applied, when range selection happened. Use e.preventDefault() to prevent edit data set and use you own.
         */
        "onBeforerangeedit"?: (event: RevoGridCustomEvent<BeforeRangeSaveDataDetails>) => void;
        /**
          * Before row definition
         */
        "onBeforerowdefinition"?: (event: RevoGridCustomEvent<{ vals: any; oldVals: any }>) => void;
        /**
          * Before sorting event. Initial sorting triggered, if this event stops no other event called. Use e.preventDefault() to prevent sorting.
         */
        "onBeforesorting"?: (event: RevoGridCustomEvent<{
    column: ColumnRegular;
    order: 'desc' | 'asc';
    additive: boolean;
  }>) => void;
        /**
          * Before sorting apply. Use e.preventDefault() to prevent sorting data change.
         */
        "onBeforesortingapply"?: (event: RevoGridCustomEvent<{
    column: ColumnRegular;
    order: 'desc' | 'asc';
    additive: boolean;
  }>) => void;
        /**
          * Before data apply. You can override data source here
         */
        "onBeforesourceset"?: (event: RevoGridCustomEvent<{
    type: DimensionRows;
    source: DataType[];
  }>) => void;
        /**
          * Before source update sorting apply. Use this event if you intended to prevent sorting on data update. Use e.preventDefault() to prevent sorting data change during rows source update.
         */
        "onBeforesourcesortingapply"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * Before trimmed values Use e.preventDefault() to prevent value trimming Update
          * @trimmed if you wish to filter indexes of trimming
         */
        "onBeforetrimmed"?: (event: RevoGridCustomEvent<{
    trimmed: Record<number, boolean>;
    trimmedType: string;
    type: string;
  }>) => void;
        /**
          * contentsizechanged event. Triggered when new content size applied. Not including header size Event is not returning size To get actual size use getContentSize after event triggered
         */
        "onContentsizechanged"?: (event: RevoGridCustomEvent<MultiDimensionType>) => void;
        /**
          * External subscribe
         */
        "onFilterconfigchanged"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * On header click.
         */
        "onHeaderclick"?: (event: RevoGridCustomEvent<ColumnRegular>) => void;
        /**
          * Row order change started. Use e.preventDefault() to prevent rgRow order change. Use e.text = 'new name' to change item name on start.
         */
        "onRowdragstart"?: (event: RevoGridCustomEvent<{
    pos: PositionItem;
    text: string;
  }>) => void;
        "onRowheaderschanged"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * Before rgRow order apply. Use e.preventDefault() to prevent rgRow order change.
         */
        "onRoworderchanged"?: (event: RevoGridCustomEvent<{ from: number; to: number }>) => void;
        /**
          * Triggered when view port scrolled
         */
        "onViewportscroll"?: (event: RevoGridCustomEvent<ViewPortScrollEvent>) => void;
        /**
          * Pinned bottom Source: {[T in ColumnProp]: any} - defines pinned bottom rows data source.
         */
        "pinnedBottomSource"?: DataType[];
        /**
          * Pinned top Source: {[T in ColumnProp]: any} - defines pinned top rows data source.
         */
        "pinnedTopSource"?: DataType[];
        /**
          * Custom grid plugins Has to be predefined during first grid init Every plugin should be inherited from BasePlugin
         */
        "plugins"?: PluginExternalConstructor[];
        /**
          * When true, user can range selection.
         */
        "range"?: boolean;
        /**
          * When true, grid in read only mode.
         */
        "readonly"?: boolean;
        /**
          * When true, columns are resizable.
         */
        "resize"?: boolean;
        /**
          * Row class property Define this property in rgRow object and this will be mapped as rgRow class
         */
        "rowClass"?: string;
        /**
          * Row properies applied
         */
        "rowDefinitions"?: RowDefinition[];
        /**
          * Excel like show rgRow indexe per rgRow
         */
        "rowHeaders"?: RowHeaders | boolean;
        /**
          * Indicates default rgRow size. By default 0, means theme package size will be applied
         */
        "rowSize"?: number;
        /**
          * Source - defines main data source. Can be an Object or 2 dimensional array([][]); Keys/indexes referenced from columns Prop
         */
        "source"?: DataType[];
        /**
          * Defines stretch strategy for columns with
          * @StretchColumn plugin if there are more space on the right last column size would be increased
         */
        "stretch"?: boolean | string;
        /**
          * Theme name
         */
        "theme"?: Theme;
        /**
          * Trimmed rows Functionality which allows to hide rows from main data set
          * @trimmedRows are physical rgRow indexes to hide
         */
        "trimmedRows"?: Record<number, boolean>;
        /**
          * When true enable clipboard.
         */
        "useClipboard"?: boolean;
    }
    /**
     * Component is responsible for rendering cell
     * Main purpose is to track changes and understand what exactly need to be rerendered instead of full grid render
     */
    interface RevogrCell {
        /**
          * Additional data to pass to renderer Used in plugins such as vue or react to pass root app entity to cells
         */
        "additionalData"?: any;
        "colEnd": number;
        /**
          * Column props passed via property
         */
        "colIndex": number;
        "colSize": number;
        "colStart": number;
        /**
          * Column service
         */
        "columnService": ColumnService;
        /**
          * Grouping
         */
        "depth"?: number;
        /**
          * Before each cell render function. Allows to override cell properties
         */
        "onBefore-cell-render"?: (event: RevogrCellCustomEvent<BeforeCellRenderEvent>) => void;
        "onDragStartCell"?: (event: RevogrCellCustomEvent<DragStartEvent>) => void;
        /**
          * Cached providers
         */
        "providers": Providers;
        "rowEnd": number;
        /**
          * Row props passed via property
         */
        "rowIndex": number;
        "rowSize": number;
        "rowStart": number;
    }
    interface RevogrClipboard {
        /**
          * Fired after paste applied to the grid
          * @event afterpasteapply
          * @property {string} raw - raw data from clipboard
          * @property {string[][]} parsed - parsed data
          * @property {ClipboardEvent} event - original event
          * @property {boolean} defaultPrevented - if true, paste will be canceled
         */
        "onAfterpasteapply"?: (event: RevogrClipboardCustomEvent<any>) => void;
        /**
          * Fired before copy triggered
          * @event beforecopy
          * @property {ClipboardEvent} event - original event
          * @property {boolean} defaultPrevented - if true, copy will be canceled
         */
        "onBeforecopy"?: (event: RevogrClipboardCustomEvent<any>) => void;
        /**
          * Fired before copy applied to the clipboard
          * @event beforecopyapply
          * @property {DataTransfer} event - original event
          * @property {string} data - data to copy
          * @property {boolean} defaultPrevented - if true, copy will be canceled
         */
        "onBeforecopyapply"?: (event: RevogrClipboardCustomEvent<any>) => void;
        /**
          * Fired before cut triggered
          * @event beforecopy
          * @property {ClipboardEvent} event - original event
          * @property {boolean} defaultPrevented - if true, cut will be canceled
         */
        "onBeforecut"?: (event: RevogrClipboardCustomEvent<any>) => void;
        /**
          * Fired before paste applied to the grid
          * @event beforepaste
          * @property {string} raw - raw data from clipboard
          * @property {ClipboardEvent} event - original event
          * @property {boolean} defaultPrevented - if true, paste will be canceled
         */
        "onBeforepaste"?: (event: RevogrClipboardCustomEvent<any>) => void;
        /**
          * Fired before paste applied to the grid and after data parsed
          * @event beforepasteapply
          * @property {string} raw - raw data from clipboard
          * @property {string[][]} parsed - parsed data
         */
        "onBeforepasteapply"?: (event: RevogrClipboardCustomEvent<any>) => void;
        /**
          * Clears region when cut is done
         */
        "onClearRegion"?: (event: RevogrClipboardCustomEvent<DataTransfer>) => void;
        /**
          * Fired when region copied
          * @event copyregion
          * @property {DataTransfer} data - data to copy
          * @property {boolean} defaultPrevented - if true, copy will be canceled
         */
        "onCopyRegion"?: (event: RevogrClipboardCustomEvent<DataTransfer>) => void;
        /**
          * Fired when region pasted
          * @event pasteregion
          * @property {string[][]} data - data to paste
          * @property {boolean} defaultPrevented - if true, paste will be canceled
         */
        "onPasteRegion"?: (event: RevogrClipboardCustomEvent<string[][]>) => void;
        /**
          * If readonly mode enables no need for Paste event
         */
        "readonly"?: boolean;
    }
    /**
     * This component is responsible for rendering data
     * Rows, columns, groups and cells
     */
    interface RevogrData {
        /**
          * Additional data to pass to renderer Used in plugins such as vue or react to pass root app entity to cells
         */
        "additionalData"?: any;
        /**
          * Static stores, not expected to change during component lifetime
         */
        "colData": ColumnSource;
        "dataStore": RowSource;
        "dimensionRow": Observable<DimensionSettingsState>;
        /**
          * When data render finished for the designated type
         */
        "onAfterrender"?: (event: RevogrDataCustomEvent<any>) => void;
        /**
          * Before each row render
         */
        "onBeforerowrender"?: (event: RevogrDataCustomEvent<BeforeRowRenderEvent>) => void;
        /**
          * Range allowed
         */
        "range"?: boolean;
        /**
          * Readonly mode
         */
        "readonly"?: boolean;
        /**
          * Defines property from which to read row class
         */
        "rowClass"?: string;
        /**
          * Stores
         */
        "rowSelectionStore": Observable<SelectionStoreState>;
        "type": DimensionRows;
        "viewportCol": Observable<ViewportState>;
        "viewportRow": Observable<ViewportState>;
    }
    /**
     * Cell editor component
     */
    interface RevogrEdit {
        /**
          * Additional data to pass to renderer
         */
        "additionalData"?: any;
        "column"?: ColumnRegular | null;
        "editCell"?: EditCell;
        /**
          * Custom editors register
         */
        "editor"?: EditorCtr | null;
        /**
          * Cell edit event
         */
        "onCellEdit"?: (event: RevogrEditCustomEvent<SaveDataDetails>) => void;
        /**
          * Close editor event pass true if requires focus next
         */
        "onCloseEdit"?: (event: RevogrEditCustomEvent<boolean | undefined>) => void;
        /**
          * Save on editor close
         */
        "saveOnClose"?: boolean;
    }
    interface RevogrFilterPanel {
        "disableDynamicFiltering"?: boolean;
        "filterCaptions"?: FilterCaptions | undefined;
        "filterEntities"?: Record<string, LogicFunction>;
        "filterItems"?: MultiFilterItem;
        "filterNames"?: Record<string, string>;
        "filterTypes"?: Record<string, string[]>;
        "onFilterChange"?: (event: RevogrFilterPanelCustomEvent<MultiFilterItem>) => void;
        "uuid"?: string;
    }
    interface RevogrFocus {
        "colData": ColumnSource;
        "colType": DimensionCols;
        "dataStore": RowSource;
        "dimensionCol": Observable<DimensionSettingsState>;
        "dimensionRow": Observable<DimensionSettingsState>;
        "focusTemplate"?: FocusTemplateFunc | null;
        /**
          * Used to setup properties after focus was rendered
         */
        "onAfterfocus"?: (event: RevogrFocusCustomEvent<{
    model: any;
    column: ColumnRegular;
  }>) => void;
        "onBefore-focus-render"?: (event: RevogrFocusCustomEvent<FocusRenderEvent>) => void;
        /**
          * Before focus changed verify if it's in view and scroll viewport into this view Can be prevented by event.preventDefault()
         */
        "onBeforescrollintoview"?: (event: RevogrFocusCustomEvent<{ el: HTMLElement }>) => void;
        "rowType": DimensionRows;
        /**
          * Dynamic stores
         */
        "selectionStore": Observable<SelectionStoreState>;
    }
    interface RevogrHeader {
        /**
          * Extra properties to pass into header renderer, such as vue or react components to handle parent
         */
        "additionalData"?: any;
        /**
          * If columns can be resized
         */
        "canResize"?: boolean;
        /**
          * Columns - defines an array of grid columns.
         */
        "colData"?: ColumnRegular[];
        /**
          * Column filter
         */
        "columnFilter"?: boolean;
        "dimensionCol"?: Observable<DimensionSettingsState>;
        "groupingDepth"?: number;
        "groups"?: Groups;
        "onBefore-resize"?: (event: RevogrHeaderCustomEvent<ColumnRegular[]>) => void;
        "onHeaderdblClick"?: (event: RevogrHeaderCustomEvent<InitialHeaderClick>) => void;
        "onHeaderresize"?: (event: RevogrHeaderCustomEvent<ViewSettingSizeProp>) => void;
        "onInitialHeaderClick"?: (event: RevogrHeaderCustomEvent<InitialHeaderClick>) => void;
        "parent"?: string;
        /**
          * Readonly mode
         */
        "readonly"?: boolean;
        /**
          * Defines resize position
         */
        "resizeHandler"?: ResizeProps['active'];
        "selectionStore"?: Observable<SelectionStoreState>;
        /**
          * Column type
         */
        "type": DimensionCols | 'rowHeaders';
        /**
          * Stores
         */
        "viewportCol"?: Observable<ViewportState>;
    }
    interface RevogrOrderEditor {
        /**
          * Static stores, not expected to change during component lifetime
         */
        "dataStore"?: Observable<DSourceState<DataType, DimensionRows>>;
        "dimensionCol"?: Observable<DimensionSettingsState>;
        "dimensionRow"?: Observable<DimensionSettingsState>;
        /**
          * Row dragged, new range ready to be applied
         */
        "onInitialRowDropped"?: (event: RevogrOrderEditorCustomEvent<{ from: number; to: number }>) => void;
        /**
          * Row move
         */
        "onInternalRowDrag"?: (event: RevogrOrderEditorCustomEvent<PositionItem>) => void;
        /**
          * Row drag ended
         */
        "onInternalRowDragEnd"?: (event: RevogrOrderEditorCustomEvent<any>) => void;
        /**
          * Row drag started
         */
        "onInternalRowDragStart"?: (event: RevogrOrderEditorCustomEvent<{
    cell: Cell;
    text: string;
    pos: PositionItem;
    event: MouseEvent;
  }>) => void;
        /**
          * Row mouse move
         */
        "onInternalRowMouseMove"?: (event: RevogrOrderEditorCustomEvent<Cell>) => void;
        "parent"?: HTMLElement;
    }
    interface RevogrOverlaySelection {
        /**
          * Additional data to pass to renderer
         */
        "additionalData"?: any;
        /**
          * If true applys changes when cell closes if not Escape
         */
        "applyChangesOnClose"?: boolean;
        /**
          * Enable revogr-order-editor component (read more in revogr-order-editor component) Allows D&D
         */
        "canDrag"?: boolean;
        /**
          * Column data store
         */
        "colData"?: Observable1<DSourceState<ColumnRegular1, DimensionCols1>>;
        /**
          * Row data store
         */
        "dataStore"?: Observable1<DSourceState<DataType1, DimensionRows1>>;
        "dimensionCol"?: Observable1<DimensionSettingsState1>;
        "dimensionRow"?: Observable1<DimensionSettingsState1>;
        /**
          * Custom editors register
         */
        "editors"?: Editors;
        /**
          * Is mobile view mode
         */
        "isMobileDevice"?: boolean;
        /**
          * Last cell position
         */
        "lastCell"?: Cell1;
        "onApplyFocus"?: (event: RevogrOverlaySelectionCustomEvent<FocusRenderEvent>) => void;
        "onBefore-apply-range"?: (event: RevogrOverlaySelectionCustomEvent<FocusRenderEvent>) => void;
        /**
          * Runs before cell save Can be used to override or cancel original save
         */
        "onBefore-cell-save"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        "onBefore-edit-render"?: (event: RevogrOverlaySelectionCustomEvent<FocusRenderEvent>) => void;
        /**
          * Before range selection applied
         */
        "onBefore-set-range"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        "onBeforeFocusCell"?: (event: RevogrOverlaySelectionCustomEvent<BeforeSaveDataDetails>) => void;
        /**
          * Selection range changed
         */
        "onBeforeRangeCopyApply"?: (event: RevogrOverlaySelectionCustomEvent<ChangedRange>) => void;
        /**
          * Range data apply
         */
        "onBeforeRangeDataApply"?: (event: RevogrOverlaySelectionCustomEvent<FocusRenderEvent>) => void;
        /**
          * Before key up event proxy, used to prevent key up trigger. If you have some custom behaviour event, use this event to check if it wasn't processed by internal logic. Call preventDefault()
         */
        "onBeforekeydown"?: (event: RevogrOverlaySelectionCustomEvent<KeyboardEvent>) => void;
        /**
          * Before key down event proxy, used to prevent key down trigger. If you have some custom behaviour event, use this event to check if it wasn't processed by internal logic. Call preventDefault()
         */
        "onBeforekeyup"?: (event: RevogrOverlaySelectionCustomEvent<KeyboardEvent>) => void;
        /**
          * Used for editors support when close requested
         */
        "onCancelEdit"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        "onFocusCell"?: (event: RevogrOverlaySelectionCustomEvent<ApplyFocusEvent>) => void;
        "onInternalCellEdit"?: (event: RevogrOverlaySelectionCustomEvent<BeforeSaveDataDetails>) => void;
        /**
          * Before clipboard copy happened
         */
        "onInternalCopy"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        /**
          * Before paste happened
         */
        "onInternalPaste"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        /**
          * Range data apply
         */
        "onInternalRangeDataApply"?: (event: RevogrOverlaySelectionCustomEvent<BeforeRangeSaveDataDetails>) => void;
        /**
          * Selection range changed
         */
        "onInternalSelectionChanged"?: (event: RevogrOverlaySelectionCustomEvent<ChangedRange>) => void;
        /**
          * Range copy
         */
        "onRangeClipboardCopy"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        "onRangeClipboardPaste"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        "onSelectall"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        /**
          * Set edit cell
         */
        "onSetEdit"?: (event: RevogrOverlaySelectionCustomEvent<BeforeEdit>) => void;
        "onSetRange"?: (event: RevogrOverlaySelectionCustomEvent<RangeArea & { type: MultiDimensionType }>) => void;
        "onSetTempRange"?: (event: RevogrOverlaySelectionCustomEvent<TempRange | null>) => void;
        /**
          * Range selection mode
         */
        "range"?: boolean;
        /**
          * If readonly mode enables
         */
        "readonly"?: boolean;
        "selectionStore"?: Observable1<SelectionStoreState1>;
        /**
          * Enable revogr-clipboard component (read more in revogr-clipboard component) Allows copy/paste
         */
        "useClipboard"?: boolean;
    }
    /**
     * Row headers component
     * Visible on the left side of the table
     */
    interface RevogrRowHeaders {
        /**
          * Additional data to pass to renderer
         */
        "additionalData"?: any;
        "dataPorts"?: ViewportData[];
        "headerProp"?: Record<string, any>;
        "height"?: number;
        "onElementToScroll"?: (event: RevogrRowHeadersCustomEvent<ElementScroll>) => void;
        "onScrollViewport"?: (event: RevogrRowHeadersCustomEvent<ViewPortScrollEvent>) => void;
        "resize"?: boolean;
        "rowClass"?: string;
        "rowHeaderColumn"?: RowHeaders;
        "uiid"?: string;
    }
    interface RevogrScrollVirtual {
        "dimension"?: DimensionType;
        "dimensionStore"?: Observable<DimensionSettingsState>;
        "onScrollVirtual"?: (event: RevogrScrollVirtualCustomEvent<ViewPortScrollEvent>) => void;
        "viewportStore"?: Observable<ViewportState>;
    }
    /**
     * Temporary range selection
     */
    interface RevogrTempRange {
        /**
          * Dimension column store
         */
        "dimensionCol"?: Observable<DimensionSettingsState>;
        /**
          * Dimension row store
         */
        "dimensionRow"?: Observable<DimensionSettingsState>;
        /**
          * Selection store, shows current selection and focus
         */
        "selectionStore"?: Observable<SelectionStoreState>;
    }
    interface RevogrViewportScroll {
        /**
          * Height of inner content
         */
        "contentHeight"?: number;
        /**
          * Width of inner content
         */
        "contentWidth"?: number;
        "onResizeViewport"?: (event: RevogrViewportScrollCustomEvent<ViewPortResizeEvent>) => void;
        "onScrollViewport"?: (event: RevogrViewportScrollCustomEvent<ViewPortScrollEvent>) => void;
        "onScrollchange"?: (event: RevogrViewportScrollCustomEvent<{
    type: DimensionType;
    hasScroll: boolean;
  }>) => void;
        /**
          * Silently scroll to coordinate Made to align negative coordinates for mobile devices
         */
        "onSilentScroll"?: (event: RevogrViewportScrollCustomEvent<ViewPortScrollEvent>) => void;
        "rowHeader"?: boolean;
    }
    interface IntrinsicElements {
        "revo-grid": RevoGrid;
        "revogr-cell": RevogrCell;
        "revogr-clipboard": RevogrClipboard;
        "revogr-data": RevogrData;
        "revogr-edit": RevogrEdit;
        "revogr-filter-panel": RevogrFilterPanel;
        "revogr-focus": RevogrFocus;
        "revogr-header": RevogrHeader;
        "revogr-order-editor": RevogrOrderEditor;
        "revogr-overlay-selection": RevogrOverlaySelection;
        "revogr-row-headers": RevogrRowHeaders;
        "revogr-scroll-virtual": RevogrScrollVirtual;
        "revogr-temp-range": RevogrTempRange;
        "revogr-viewport-scroll": RevogrViewportScroll;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Slots
             * @example data-rgCol-rgRow - main data slot
             * @example focus-rgCol-rgRow - focus layer for main data
             */
            "revo-grid": LocalJSX.RevoGrid & JSXBase.HTMLAttributes<HTMLRevoGridElement>;
            /**
             * Component is responsible for rendering cell
             * Main purpose is to track changes and understand what exactly need to be rerendered instead of full grid render
             */
            "revogr-cell": LocalJSX.RevogrCell & JSXBase.HTMLAttributes<HTMLRevogrCellElement>;
            "revogr-clipboard": LocalJSX.RevogrClipboard & JSXBase.HTMLAttributes<HTMLRevogrClipboardElement>;
            /**
             * This component is responsible for rendering data
             * Rows, columns, groups and cells
             */
            "revogr-data": LocalJSX.RevogrData & JSXBase.HTMLAttributes<HTMLRevogrDataElement>;
            /**
             * Cell editor component
             */
            "revogr-edit": LocalJSX.RevogrEdit & JSXBase.HTMLAttributes<HTMLRevogrEditElement>;
            "revogr-filter-panel": LocalJSX.RevogrFilterPanel & JSXBase.HTMLAttributes<HTMLRevogrFilterPanelElement>;
            "revogr-focus": LocalJSX.RevogrFocus & JSXBase.HTMLAttributes<HTMLRevogrFocusElement>;
            "revogr-header": LocalJSX.RevogrHeader & JSXBase.HTMLAttributes<HTMLRevogrHeaderElement>;
            "revogr-order-editor": LocalJSX.RevogrOrderEditor & JSXBase.HTMLAttributes<HTMLRevogrOrderEditorElement>;
            "revogr-overlay-selection": LocalJSX.RevogrOverlaySelection & JSXBase.HTMLAttributes<HTMLRevogrOverlaySelectionElement>;
            /**
             * Row headers component
             * Visible on the left side of the table
             */
            "revogr-row-headers": LocalJSX.RevogrRowHeaders & JSXBase.HTMLAttributes<HTMLRevogrRowHeadersElement>;
            "revogr-scroll-virtual": LocalJSX.RevogrScrollVirtual & JSXBase.HTMLAttributes<HTMLRevogrScrollVirtualElement>;
            /**
             * Temporary range selection
             */
            "revogr-temp-range": LocalJSX.RevogrTempRange & JSXBase.HTMLAttributes<HTMLRevogrTempRangeElement>;
            "revogr-viewport-scroll": LocalJSX.RevogrViewportScroll & JSXBase.HTMLAttributes<HTMLRevogrViewportScrollElement>;
        }
    }
}
